/*
 * grunt-depconcat
 * https://github.com/terrykingcha/grunt-depconcat
 *
 * Copyright (c) 2013 tERry.K
 * Licensed under the MIT license.
 */
var path = require('path'),
    util = require('util');

'use strict';

module.exports = function(grunt) {

  function analyse(tree) {
    var opptree = {}, counttree = {}, queue = [], src = [],
        filepath, deplist, depfile;

    for (var filepath in tree) {
      deplist = tree[filepath];

      for (var i = 0; i < deplist.length; i++) {
        depfile = deplist[i];
        opptree[depfile] || (opptree[depfile] = []);
        opptree[depfile].push(filepath);
      }

      !(counttree[filepath] = tree[filepath].length) && queue.push(filepath);
    }

    while(queue.length) {
        var cur = queue.shift();
        src.push(cur);

        if(opptree[cur]) {
          opptree[cur].forEach(function(dep){
            if(--counttree[dep] === 0)
              queue.push(dep);
          });
        }
    }

    return src;
  }

  function isExcept(except, filepath) {
    if (!(except instanceof Array)) except = [except];

    for (var i = 0; i < except.length; i++) {
      var e = except[i];
      if (!(e instanceof RegExp)) {
        e = except[i] = new RegExp(except[i] + '$');
      }
      if (filepath.match(e)) return true;
    }
    return false;
  }

  // Please see the Grunt documentation for more information regarding task
  // creation: http://gruntjs.com/creating-tasks

  grunt.registerMultiTask('depconcat', 'Concat depended files', function() {
    var JS_REQUIRE_TEMPLATE = '\\/\\/@require ([\\w\\.]+)',
        CSS_REQUIRE_TEMPLATE = '@import url\\(["\']?([\\w\\.]+)["\']?\\);?'
        ;
    // Merge task-specific and/or target-specific options with these defaults.
    var options = this.options({
          separator: grunt.util.linefeed,
          requireTemplate: null,
          ext: null,
          except: [],
        });

    // Iterate over all specified file groups.
    this.files.forEach(function(f) {
      options.ext || (options.ext = f.dest.match(/\.[a-z]+$/i)[0]);

      if (!options.requireTemplate) {
        if (options.ext === '.css') {
          var requireTemplate = CSS_REQUIRE_TEMPLATE;
        } else {
          var requireTemplate = JS_REQUIRE_TEMPLATE;
        }
      } else if (typeof options.requireTemplate === 'string'){
        var requireTemplate = options.requireTemplate;
      }

      requireTemplate && (options.requireTemplate = new RegExp(requireTemplate, 'gi'));

      if (f.src) {
        // Concat specified files.
        var tree = {}, src;

        src = f.src.filter(function(filepath) {
          // Warn on and remove invalid source files.
          if (!grunt.file.exists(filepath)) {
            grunt.log.warn('Source file "' + filepath + '" not found.');
            return false;
          } else {
            return !isExcept(options.except, filepath);
          }
        })

        for (var i = 0; i < src.length; i++) {
          var filepath = src[i],
              file = grunt.file.read(filepath), 
              matches = file.match(options.requireTemplate) || []
              ;

          matches = matches.map(function(match) {
              options.requireTemplate.lastIndex = 0;
              var depfilepath = options.requireTemplate.exec(match)[1];

              if (!depfilepath.match(/\.\w+$/)) {
                depfilepath = depfilepath + options.ext;
              }

              if (!isExcept(options.except, depfilepath)) {
                depfilepath = path.normalize(path.join(path.dirname(filepath), depfilepath));
                if (src.indexOf(depfilepath) < 0) {
                  src.push(depfilepath);
                }
                return depfilepath;
              }
          }).filter(function(f) {
            return f;
          });

          tree[path.normalize(filepath)] = matches;
        }

      } else if (f.tree) {

        if (typeof f.tree === 'string') {
          var tree = grunt.file.readJSON(f.tree).
              names = Object.keys(tree),
              treeDir = path.dirname(f.tree);

          names.forEach(function(filepath) {
            tree[path.normalize(path.join(treeDir, filepath))] = tree[filepath].map(function(depfile) {
              return path.normalize(path.join(treeDir, depfile));
            });
            delete tree[filepath];
          });
        } else {
          var tree = f.tree;
        }
      }

      var sortedSrc = analyse(tree).map(function(filepath) {
        // Read file source.
        return grunt.file.read(filepath).replace(options.requireTemplate, '');
      });

      grunt.file.write(f.dest, sortedSrc.join(grunt.util.linefeed));
      grunt.log.writeln('Dest File "' + f.dest + '" created.');
    });
  });

};
